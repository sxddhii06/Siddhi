Q.8Write a program in C to Create a graph of al-least 5 nodes find and
print BFS.
#include <stdio.h>
#include <conio.h>
#define MAX 20
int adj[MAX][MAX];
int visited[MAX];
int queue[MAX];
int front = -1, rear = -1;
void enqueue(int v)
{
if (rear == MAX - 1)
printf("Queue Overflow!\n");
else
{
if (front == -1)
front = 0;
rear++;
queue[rear] = v;
}
}
int dequeue()
{
int v;
if (front == -1 || front > rear)
return -1;
v = queue[front];
front++;
return v;
}
void BFS(int start, int vertices)
{
int i, current;
for (i = 0; i < vertices; i++)
visited[i] = 0;
enqueue(start);
visited[start] = 1;
printf("\nBFS Traversal starting from node %d: ", start);
while ((current = dequeue()) != -1)
{
printf("%d ", current);
for (i = 0; i < vertices; i++)
{
if (adj[current][i] == 1 && visited[i] == 0)
{
enqueue(i);
visited[i] = 1;
}
}
}
}
void main()
{
int vertices, edges;
int i, j, src, dest, start;
clrscr(); // clear screen
printf("=== Create Graph and Perform BFS Traversal ===\n");
printf("Enter number of vertices (at least 5): ");
scanf("%d", &vertices);
if (vertices < 5)
{
printf("Graph must have at least 5 nodes!\n");
getch();
return;
}
printf("Enter number of edges: ");
scanf("%d", &edges);
// Initialize adjacency matrix
for (i = 0; i < vertices; i++)
for (j = 0; j < vertices; j++)
adj[i][j] = 0;
printf("\nEnter edges (source destination):\n");
for (i = 0; i < edges; i++)
{
printf("Edge %d: ", i + 1);
scanf("%d %d", &src, &dest);
adj[src][dest] = 1;
// Uncomment this for undirected graph:
// adj[dest][src] = 1;
}
printf("\nEnter starting node for BFS: ");
scanf("%d", &start);
BFS(start, vertices);
getch();
}

Algoritm

Start
2. Input number of vertices
Read vertices
If vertices < 5 → print error → stop
3. Input number of edges
Read edges
4. Initialize the adjacency matrix
For every i and j
Set adj[i][j] = 0
(This means no edges initially.)
5. Read edges and fill adjacency matrix
Repeat for each edge:
Read source node → src
Read destination node → destSet adj[src][dest] = 1
(This marks a connection between nodes.)
6. Input starting node for BFS
Read start
✅ 7. Initialize visited array
For each vertex:
Set visited[i] = 0
✅ 8. Start BFS
Enqueue the starting node → start
Mark visited[start] = 1
9. While the queue is not empty:
Dequeue a node → call it current
Print current
For each vertex i:
If adj[current][i] == 1 (means there is a link)
AND visited[i] == 0 (not visited yet)
Enqueue i
Mark visited[i] = 1
10. Continue until queue is empty
11. End
